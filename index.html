<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Διατμητική Ανηγμένη Παραμόρφωση</title>
<style>
body{
  margin:0; overflow:hidden; display:flex; align-items:center; justify-content:center;
  height:100vh; background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
  font-family:'Roboto',Arial,sans-serif;
}
#sliderContainer{
  position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
  background:rgba(255,255,255,.95); padding:15px 20px; border-radius:10px;
  box-shadow:0 4px 15px rgba(0,0,0,.1); backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,.2);
}
#title{
  position:absolute; top:20px; left:50%; transform:translateX(-50%);
  color:#2c3e50; text-align:center; text-shadow:0 2px 4px rgba(0,0,0,.1);
}
#title h1{margin:0 0 5px 0; font-size:28px; font-weight:300; letter-spacing:2px;}
#title h2{margin:0 0 10px 0; font-size:20px; font-weight:400; color:#34495e;}
#title p{margin:0; font-size:14px; color:#7f8c8d; font-style:italic;}
input[type=range]{
  width:250px; height:6px; border-radius:3px; background:#ddd; outline:none;
  -webkit-appearance:none; margin:10px 0;
}
input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none; appearance:none; width:20px; height:20px; border-radius:50%;
  background:#3498db; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,.2);
}
input[type=range]::-moz-range-thumb{
  width:20px; height:20px; border-radius:50%; background:#3498db; cursor:pointer; border:none;
  box-shadow:0 2px 6px rgba(0,0,0,.2);
}
#instructions{
  position:absolute; top:20px; right:20px; color:#2c3e50; font-size:13px;
  background:rgba(255,255,255,.9); padding:15px; border-radius:8px;
  box-shadow:0 2px 10px rgba(0,0,0,.1); backdrop-filter:blur(5px); max-width:240px;
}
#resetButton{
  width:100%; margin-bottom:15px; padding:10px; background:linear-gradient(45deg,#3498db,#2980b9);
  color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:14px; font-weight:500;
  transition:all .3s ease; box-shadow:0 2px 8px rgba(52,152,219,.3);
}
#resetButton:hover{ background:linear-gradient(45deg,#2980b9,#1f618d); transform:translateY(-1px); box-shadow:0 4px 12px rgba(52,152,219,.4);}
#gammaDisplay{ text-align:center; font-size:16px; font-weight:500; color:#2c3e50; margin-top:5px;}
.slider-label{ font-size:14px; color:#34495e; text-align:center; margin-bottom:5px;}
canvas{ cursor:grab;} canvas:active{ cursor:grabbing;}
#equations{
  position:absolute; left:20px; bottom:20px; color:#2c3e50; font-size:13px;
  background:rgba(255,255,255,.92); padding:12px 14px; border-radius:8px;
  box-shadow:0 2px 10px rgba(0,0,0,.1); backdrop-filter:blur(6px); max-width:320px; line-height:1.35;
}
#equations code{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;}
</style>
</head>
<body>
<div id="title">
  <h1>ΑΝΤΟΧΗ ΥΛΙΚΩΝ</h1>
  <h2>Διατμητική Ανηγμένη Παραμόρφωση</h2>
  <p>Χρησιμοποιήστε το ρυθμιστικό για να αλλάξετε την γωνία διατμητικής παραμόρφωσης</p>
</div>

<div id="instructions">
  <strong>Χειρισμοί:</strong><br>
  • Σύρετε για περιστροφή<br>
  • Ρυθμιστικό για γωνία διάτμησης<br>
  • Κόκκινη γραμμή = άξονας X<br>
  • Πράσινη γραμμή = άξονας Y′ (με διάτμηση)<br>
  • Κόκκινα βέλη = Διατμητικές δυνάμεις (τ)<br>
  • γ = γωνία διάτμησης
</div>

<div id="equations">
  <div><strong>Simple shear (x-shear):</strong></div>
  <div style="margin-top:6px">
    <code>[x', y', z']ᵀ = [[1, tan(γ), 0], [0, 1, 0], [0, 0, 1]] · [x, y, z]ᵀ</code>
  </div>
  <div style="margin-top:6px">
    <code>x' = x + tan(γ)·y,&nbsp;&nbsp;y' = y</code>
  </div>
  <div style="margin-top:6px">
    Small-strain: <code>tan(γ) ≈ γ (rad)</code> ⇒ <code>γ<sub>xy</sub>=γ</code>
  </div>
</div>

<div id="sliderContainer">
  <button id="resetButton">Επαναφορά Κύβου</button>
  <div class="slider-label">Γωνία Διάτμησης (γ)</div>
  <input type="range" id="gammaRange" min="-45" max="45" value="0" step="0.5">
  <div id="gammaDisplay">γ = <span id="gammaValue">0.0</span>°</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>
// --- Scene ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf8f9fa);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

camera.position.set(5,4,7);
camera.lookAt(0,0,0);

// --- Lights ---
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(8,10,5);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(2048,2048);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404040, .6));
const fillLight = new THREE.DirectionalLight(0x8ec5fc, .3);
fillLight.position.set(-5,3,-5);
scene.add(fillLight);

// --- Group ---
const cubeGroup = new THREE.Group();
cubeGroup.position.y = -0.3;
scene.add(cubeGroup);

// --- Cube ---
const mat = new THREE.MeshPhongMaterial({
  color:0x74b9ff, opacity:.85, transparent:true, shininess:60, specular:0x222222
});
const baseGeom = new THREE.BoxGeometry(2,2,2);
let cube = new THREE.Mesh(baseGeom.clone(), mat);
cube.castShadow = cube.receiveShadow = true;
cubeGroup.add(cube);

// --- Axes ---
function createAxes(){
  const g = new THREE.Group();

  const gx = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-1.8,0,0), new THREE.Vector3(1.8,0,0)
  ]);
  const mx = new THREE.LineBasicMaterial({ color:0xe74c3c, linewidth:4 });
  const xAxis = new THREE.Line(gx,mx);

  const ax = new THREE.ConeGeometry(0.06,0.15,8);
  const xArrow = new THREE.Mesh(ax,new THREE.MeshBasicMaterial({color:0xe74c3c}));
  xArrow.rotation.z = -Math.PI/2; xArrow.position.x = 1.8;

  const gy = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,-1.8,0), new THREE.Vector3(0,1.8,0)
  ]);
  const my = new THREE.LineBasicMaterial({ color:0x27ae60, linewidth:4 });
  const yAxis = new THREE.Line(gy,my);

  const ay = new THREE.ConeGeometry(0.06,0.15,8);
  const yArrow = new THREE.Mesh(ay,new THREE.MeshBasicMaterial({color:0x27ae60}));
  yArrow.position.y = 1.8;

  g.add(xAxis,xArrow,yAxis,yArrow);
  return { axesGroup:g, xAxis, yAxis, xArrow, yArrow };
}
let { axesGroup, xAxis, yAxis, xArrow, yArrow } = createAxes();
cubeGroup.add(axesGroup);

// --- Arrow factory (TAIL at origin!) ---
function makeArrow(length=1.0, shaftR=0.04, headL=0.25, headR=0.12){
  const grp = new THREE.Group();

  // shaft along +X, tail at 0, tip before head
  const shaftLen = Math.max(0.1, length - headL);
  const shaftGeo = new THREE.CylinderGeometry(shaftR, shaftR, shaftLen, 12);
  const shaftMat = new THREE.MeshPhongMaterial({ color:0xe74c3c, shininess:80, specular:0x666666 });
  const shaft = new THREE.Mesh(shaftGeo, shaftMat);
  shaft.rotation.z = Math.PI/2;
  shaft.position.x = shaftLen/2; // so tail is at x=0
  shaft.castShadow = true;
  grp.add(shaft);

  const headGeo = new THREE.ConeGeometry(headR, headL, 8);
  const headMat = new THREE.MeshPhongMaterial({ color:0xc0392b, shininess:80, specular:0x666666 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.rotation.z = -Math.PI/2;
  head.position.x = shaftLen; // directly after shaft
  head.castShadow = true;
  grp.add(head);

  const glowGeo = new THREE.CylinderGeometry(shaftR+0.02, shaftR+0.02, length, 12);
  const glowMat = new THREE.MeshBasicMaterial({ color:0xff6b6b, transparent:true, opacity:0.25 });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  glow.rotation.z = Math.PI/2;
  glow.position.x = length/2;
  grp.add(glow);

  return grp;
}

// four arrows
const ARROW_LEN = 1.1; // long but always outside (tail at plane + clearance)
let shearForces = [makeArrow(ARROW_LEN), makeArrow(ARROW_LEN), makeArrow(ARROW_LEN), makeArrow(ARROW_LEN)];
shearForces.forEach(a => cubeGroup.add(a));

// --- Place arrows: true face normals + tail placement ---
function positionShearForces(forces, gammaRad=0){
  const s = Math.tan(gammaRad);
  const half = 1.0;                     // cube half-size
  const clear = 0.42;                   // normal offset outside the face
  const theta = Math.atan2(1, s);       // tangent angle of y' (vector [s,1])

  const inv = 1/Math.sqrt(1+s*s);
  const nR = new THREE.Vector2( 1*inv, -s*inv); // right-face unit normal (x'-s y' = +1)
  const nL = new THREE.Vector2(-1*inv,  s*inv); // left -face unit normal (x'-s y' = -1)

  const show = Math.abs(gammaRad*180/Math.PI) > 0.25;
  forces.forEach(f => f.visible = show);
  if (!show) return;

  // TOP face: plane y' = +1, normal +Y; shear traction along ±X
  const top = forces[0];
  top.position.set(s*half, half+clear, 0); // tail exactly outside plane
  top.rotation.set(0,0, gammaRad>=0 ? 0 : Math.PI); // +x (γ>0) else -x

  // BOTTOM face: plane y' = -1, normal -Y
  const bottom = forces[1];
  bottom.position.set(-s*half, -half-clear, 0);
  bottom.rotation.set(0,0, gammaRad>=0 ? Math.PI : 0);

  // RIGHT face: plane x'-s y' = +1, normal nR; arrow along +y' (θ)
  const cR = new THREE.Vector2(half, 0);             // any point on plane center line
  const pR = cR.clone().addScaledVector(nR, clear);  // tail = plane + outward normal*clear
  const right = forces[2];
  right.position.set(pR.x, pR.y, 0);
  right.rotation.set(0,0, theta);                    // align with +y'

  // LEFT face: plane x'-s y' = -1, normal nL; arrow along -y' (θ+π)
  const cL = new THREE.Vector2(-half, 0);
  const pL = cL.clone().addScaledVector(nL, clear);
  const left = forces[3];
  left.position.set(pL.x, pL.y, 0);
  left.rotation.set(0,0, theta + Math.PI);           // opposite along y'
}

// --- Axes consistent with shear ---
function updateAxes(gammaRad){
  cubeGroup.remove(axesGroup);
  const s = Math.tan(gammaRad);
  const theta = Math.atan2(1, s);

  axesGroup = new THREE.Group();

  const gx = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-1.8,0,0), new THREE.Vector3(1.8,0,0)
  ]);
  const mx = new THREE.LineBasicMaterial({ color:0xe74c3c, linewidth:4 });
  xAxis = new THREE.Line(gx,mx);

  const xArrowGeom = new THREE.ConeGeometry(0.06,0.15,8);
  xArrow = new THREE.Mesh(xArrowGeom,new THREE.MeshBasicMaterial({color:0xe74c3c}));
  xArrow.rotation.z = -Math.PI/2; xArrow.position.set(1.8,0,0);

  const gy = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(s*(-1.8), -1.8, 0), new THREE.Vector3(s*(1.8), 1.8, 0)
  ]);
  const my = new THREE.LineBasicMaterial({ color:0x27ae60, linewidth:4 });
  yAxis = new THREE.Line(gy,my);

  const yArrowGeom = new THREE.ConeGeometry(0.06,0.15,8);
  yArrow = new THREE.Mesh(yArrowGeom,new THREE.MeshBasicMaterial({color:0x27ae60}));
  yArrow.position.set(s*1.8,1.8,0);
  yArrow.rotation.z = theta - Math.PI/2;

  axesGroup.add(xAxis,xArrow,yAxis,yArrow);
  cubeGroup.add(axesGroup);

  positionShearForces(shearForces, gammaRad);
}

// --- Mouse controls with momentum ---
let isMouseDown=false, mouseX=0, mouseY=0, rotationVelocity={x:0,y:0}, isDamping=false;
function handleMouseDown(x,y){ isMouseDown=true; mouseX=x; mouseY=y; rotationVelocity={x:0,y:0}; isDamping=false; }
function handleMouseMove(x,y){
  if(!isMouseDown) return;
  const dx=x-mouseX, dy=y-mouseY, k=0.008;
  const ry = dx*k, rx = dy*k;
  cubeGroup.rotation.y += ry; cubeGroup.rotation.x += rx;
  rotationVelocity={x:rx,y:ry}; mouseX=x; mouseY=y;
}
function handleMouseUp(){ isMouseDown=false; isDamping=true; }

renderer.domElement.addEventListener('mousedown', e=>handleMouseDown(e.clientX,e.clientY));
renderer.domElement.addEventListener('mousemove', e=>handleMouseMove(e.clientX,e.clientY));
renderer.domElement.addEventListener('mouseup', handleMouseUp);
renderer.domElement.addEventListener('mouseleave', handleMouseUp);
renderer.domElement.addEventListener('touchstart', e=>{
  if(e.touches.length===1){ e.preventDefault(); handleMouseDown(e.touches[0].clientX,e.touches[0].clientY); }
});
renderer.domElement.addEventListener('touchmove', e=>{
  if(e.touches.length===1){ e.preventDefault(); handleMouseMove(e.touches[0].clientX,e.touches[0].clientY); }
});
renderer.domElement.addEventListener('touchend', e=>{ e.preventDefault(); handleMouseUp(); });

// --- Shear transform ---
function applyShear(geometry, gammaRad){
  const s = Math.tan(gammaRad);
  const M = new THREE.Matrix4().set(
    1, 0, 0, 0,
    s, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  );
  geometry.applyMatrix4(M);
}

// --- UI ---
const slider = document.getElementById('gammaRange');
const gammaValue = document.getElementById('gammaValue');
const resetButton = document.getElementById('resetButton');

resetButton.addEventListener('click', ()=>{
  const start = {x:cubeGroup.rotation.x, y:cubeGroup.rotation.y};
  const T=800, t0=Date.now();
  (function anim(){
    const p=Math.min((Date.now()-t0)/T,1), e=1-Math.pow(1-p,3);
    cubeGroup.rotation.x = start.x*(1-e);
    cubeGroup.rotation.y = start.y*(1-e);
    if(p<1) requestAnimationFrame(anim);
  })();

  slider.value=0; gammaValue.textContent='0.0';

  cubeGroup.remove(cube);
  const geom = baseGeom.clone();
  cube = new THREE.Mesh(geom,mat);
  cube.castShadow = cube.receiveShadow = true;
  cubeGroup.add(cube);

  updateAxes(0);
});

slider.addEventListener('input', ()=>{
  const deg = parseFloat(slider.value);
  gammaValue.textContent = deg.toFixed(1);
  const rad = deg*Math.PI/180;

  cubeGroup.remove(cube);
  const geom = baseGeom.clone();
  applyShear(geom, rad);
  cube = new THREE.Mesh(geom, mat);
  cube.castShadow = cube.receiveShadow = true;
  cubeGroup.add(cube);

  updateAxes(rad);
});

// --- Init ---
updateAxes(0);
positionShearForces(shearForces, 0);

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

// --- Animate ---
function animate(){
  requestAnimationFrame(animate);
  if(isDamping && (Math.abs(rotationVelocity.x)>0.001 || Math.abs(rotationVelocity.y)>0.001)){
    cubeGroup.rotation.x += rotationVelocity.x;
    cubeGroup.rotation.y += rotationVelocity.y;
    rotationVelocity.x *= 0.95; rotationVelocity.y *= 0.95;
    if(Math.abs(rotationVelocity.x)<0.001 && Math.abs(rotationVelocity.y)<0.001) isDamping=false;
  }
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
